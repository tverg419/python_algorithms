# Algorithms in Python

### November 1, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #100   | Easy       |       |
| #94    | Easy       |       |
| #144   | Easy       |       |
| #145   | Easy       |       |
| #104   | Easy       |       |

Coursera:
- Max Pairwise Product
    - Reviewing naive versus efficient solutions

---

### November 2, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #49    | Medium     |       |
| #168   | Easy       |       |

Coursera: N/A
    
---

### November 7, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|

Coursera: N/A

Udemy:
- Sequential Search (unordered, ordered)
- Binary Search (iterative, recursion)
- Bubble Sort
- Selection Sort

---

### November 8, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|


Coursera: N/A

Udemy:
- Insertion Sort
- Shell Sort

---

### November 9, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|

Coursera: N/A

Udemy:
- Quick Sort
- Merge Sort

---

### November 10, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #88    | Easy       | Incorrectly adds number from second array |
| #278   | Easy       | Makes too many calls to API |

Coursera: N/A

Udemy: N/A

---

### November 11, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #88    | Easy       |  |
| #278   | Easy       | recognize it is a searching algorithm problem. Sequential sort makes too many calls to the API. Implement binary search |
| #70    | Easy       | recognize the pattern is fibonacci. implement the efficient fibonacci solution |
| #121   | Easy       | Kadane's algorithm |

- Kadane's Algorithm
- Review the concept of dynamic programming

Coursera: N/A

Udemy: N/A

---

### November 12, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #75    | Medium     | Solve this problem using regular merge sort or quick sort. Challenge: modify the quick sort to sort after one pass given the only values can be 0, 1, 2 |

Coursera: N/A

Udemy: N/A

---

### November 12, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|

Coursera: N/A

Udemy:
- Graph Algorithms

---

### November 14, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #2     | Medium     | |

Coursera: N/A

Udemy:

---

### November 19, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #8     | Easy       |       |
| #28    | Easy       |       |
| #38    | Easy       |       |
| #14    | Easy       |       |

Coursera: N/A

Udemy:

---

### November 21, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|

Coursera: N/A

Udemy:
- Non Coding Interview Problems:
    - Bridge Crossing
    - Coins and a Scale
    - Egg Drop
    - Hallway Lockers

---

### November 22, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #111   | Easy       |       |
| #559   | Easy       |       |

Coursera: N/A

Udemy: N/A

Reviewing Behavioral Interview Questions:
- Tell me about yourself
- Tell me a time about conflict
- Tell me about a challenging project

---

### November 23, 2021
LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #24    | Medium     | if the head and next exist, recursively swap head.next. return the temporary variable and then return the head at the end |

Coursera: N/A

Udemy: N/A

---

### December 1, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #35    | Easy       |       |

Coursera: N/A

Udemy: N/A

---

### December 2, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #6     | Medium     |       |
| #11    | Medium     | sliding window algorithm |

- review sliding window algorithm

Coursera: N/A

Udemy: N/A

---

### December 3, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #22    | Medium     | backtracking algorithm |

- review backtracking algorithm

Coursera: N/A

Udemy: N/A

---

### December 5, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #24    | Medium     |  |

Coursera: N/A

Udemy: N/A

---

### December 6, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #55    | Medium     |  |

Coursera: N/A

Udemy: N/A

---

### December 8, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #66    | Easy       |  |
| #67    | Easy       |  |
| #83    | Easy       |  |

Coursera: N/A

Udemy: N/A

---

### December 9, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #108   | Easy       | basics of recursion in a BST |
| #110   | Easy       |  |
| #112   | Easy       |  |

Coursera: N/A

Udemy: N/A

---

### December 10, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #36    | Medium     |  |

Coursera: N/A

Udemy: N/A

---

### December 12, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #39    | Medium     |  |

Coursera: N/A

Udemy: N/A

---

### December 13, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #40    | Medium     |  |

Coursera: N/A

Udemy: N/A

---

### December 14, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #75    | Medium     | 3-pointer question |
| #231   | Easy       | Basic math concept |
Coursera: N/A

Udemy: N/A

Most Common Algorithm Concepts (Clement Mihailescu):
1. Depth-First search 
2. Breadth-First search
3. Stack implementation
    - Ex. brack check problem
4. Utilizing hash-tables
5. Multiple pointer technique
    - Ex. longest palindrome substring in a string
6. Reversing a  linked List
    - Ex. Identify a cycle in a linked list
7. Sorting fundamentals (time/space complexity, bubble sort, merge sort) 
8. Recursion
9. Custom data strucutres
10. Binary search

---

### December 16, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #5     | Medium     | |

Coursera: N/A

Udemy: N/A

---

### December 17, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #43     | Medium     | |

Coursera: N/A

Udemy: N/A

--- 

### December 19, 2021

LeetCode:

| Number | Difficulty | Notes |
|--------|------------|-------|
| #1200  | Easy       | |

- Review backtracking algorithm

Coursera: N/A

Udemy: N/A

--- 

### December 20, 2021
*Start Curated List of Top 75 LeetCode Questions*

**Problem:** #1 Two Sum
**Category:** Array

**Solution**
- Utilize a dictionary to store each value in the array
    - key => value from array
    - value => target - value from array
- Check the dictionary and return the pair

**Notes**
- Traversing through an array
- Use a dictionary to retain information

---

### December 21, 2021

**Problem:** #371 Sum of Two Integers
**Category:** Binary

**Solution**
- Utilize AND operator to handle carrying a digit over
- Utilize XOR (exclusive OR) operator to handle addition of bits
- Lastly, utilize left shift operator to carry bits over left

**Notes**
- Understanding bit shifting/manipulation
- Number basing (binary is number base 2)
- Understanding computational differences between base 10 operations and base 2 operations
- Utilize bitwise operators
    - AND(&), XOR(^), Left Shift (<<)

--- 

### December 22, 2021

**Problem:** #70 Climbing Stairs
**Category:** Dynamic Programming

**Solution**
- break the problem down into smaller steps
    - Ex. Step 5 is the summation of the decisions of Step 4(1-Step) & Step 3(2-Step)
    - Similarly, Step 4 is the summation of the decisions of Step 3(1-Step) & Step 2(2-Step)
- this turns the problem into a recursion problem
- our bases cases are Step(0) = 1 and Step(1) = 1

**Notes**
- recognize the problem is a dynamic programming question
- a more efficient solutions is to store the values in a list and call the list instead of redoing the calculation

---

### December 23, 2021

**Problem:** #133 Clone Graph
**Category:** Graph

**Solution**
- In order to clone a graph, we must search through it using eithter DFS or BFS
- Pick BFS
- Initialize a starting node for the copy graph
- Initialize a dictionary that holds the values of all "seen" neighbors
- Initialize a queue that remembers what nodes still need to be processed
- while a queue still exists
    - obtain next node in the queue
    - process all it's neighbors
        - add unseen nodes to queue
        - add all neighbors to output dict

**Notes**
- An **adjacency list** is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.
- **Deep Clone** is an identical creation of an object. Each refernce should return the same information, but it references the new object not the old one.
- **Shallow Clone** is a copy of the references of each field. This type of clone still refers to the same object.

---

### December 26, 2021

**Problem:** #57 Insert Interval
**Category:** Interval

**Solution**
- define a merge function
    - compares the lower bound of the old/new intervals
    - compares the upper bound of the old/new intervals
    - if the intervals overlap, take the min as the lower bound and take the max as the upper bound        

**Notes**
- recognize a greedy algorithm
- 

---

### December 27, 2021

**Problem:** #206 Reverse Linked-List
**Category:** Linked-List 

**Solution**
- Define two pointer 
    - current (holds the remaining portion of the linked list)
    - reverse (holds the reverese linked list)
- Loop:
    - store the next values temporarily
    - point the current value to the reverse to add the next value to reveresed list
    - update the reverse pointer to hold the new linked list
    - reassign current the temporatily stored values
 
**Notes**
- Defining a linked list
- Utilizing two pointers in a linked-list

---

### December 28, 2021

**Problem:** #73 Set Matrix Zeroes
**Category:** Matrices

**Solution**
- Brute Force Solution:
    - Make a copy matrix that is updated as we discover new zeroes in the original matrix and then reassign the original matrix to the copy.

- Semi-Efficient Solution
    - Create two row lists that store if a row/column contains a zero.
    - Traverse through the entire matrix.
        - if a zero is detected change both that row and column index into a zero 
    - Once all the zeroes are detected, change all the necessary cells into zeroes and return the original matrix

- Most Efficient Solution
    - Requires only constant space complexity.
    - Replaces the first row and column of the matrix and stores the markers similar to the semi-efficient solution
    - must store an extra cell of memory because the first index of the row and column overlaps

**Notes**
- traversing through an array
- recognizing the tradeoffs for space complexity
- copying matrices

---

### December 29, 2021

**Problem:** #3 Longest Substring Without Repeating Characters
**Category:** Strings

**Solution**
- Initialize a left and right pointer of the current string
- Initialize a set that will holds all the current characters
- Initialize a longest (output) variable
- Loop thorugh entire string
    - if char not in set:
        - add char to set
        - move right pointer over
    - while char in set:
        - store the current if it's the longest
        - remove leftmost char from set and move left pointer over
    - set longest to max of longest & (right - left)


**Notes**
- Sliding window problem
- Solution failed when using an if for checking char in set, but passed when using while.

---

### January 5, 2022

**Problem:** #104 Maximum Depth of a Binary Tree
**Category:** Trees

**Solution**
- Recursive Method:
    - Base Case: if the root has a value of None, return 0
    - Recursive Case: return 1 + recursive call to the left and right sides of the tree
- Try Working through each iterative case
- DFS:
- BFS: 

**Notes**
-  Depth-First Search v. Breadth First-Search

---

### January 6, 2022

**Problem:** #121 Best Time to Buy and Sell Stock
**Category:** Array

**Solution**
- Initialize a max profit variable
- Loop through the list
    - if your new number is less than current min, replace min 
    - else take the difference of your current number and the minimum and if it is larger than the current max profit update the value

**Notes**
-  Don't reassign the profit value everytime because it slows down the algorithm. Add a conditional so that it only updates the value when that conditional is met

---

### January 7, 2022

**Problem:** #191 Number of 1 Bits
**Category:** Binary

**Solution**
- Use a while loop to see if integer can be shifted (divide by 2)
    - Use AND operator to check if current n & 1 equates to 1, increment the output
- Loop exits early so you have to do one more operation to check the last bit
- return the output

**Notes**
- **Hamming weight** the number of symbols in a given string that are non-zero symbols 
- We should be able to limit the number of times we have to bit shift based on the number itself.
    - Ex. 16 > 11 => only have to check the last 4 bits

---

### January 9, 2022

**Problem:** #322 Coin Change
**Category:** Dynamic Programming

**Solution**
- Have a variable that stores the smallest amount of coins
- Have an array that stores the previous number of combinations
- Loop through each value up to the amount
    - go through each coin and see if subtracting the amount is valid
    - update value to minimum

**Notes**
- 

---

### January 10, 2022

**Problem:** #207 Course Schedule
**Category:** Graph

**Solution**
- The prerequisite component indicates the question can be solved with a directed graph
- Notice if a cycle occurs within the prerequisites, then the courses cannot be completed
- Create an adjancency list to see the neighbors of each node
- Create a dependencies array that shows how many other nodes are pointing at a given node
    - Zero dependencies is similar to not have any prerequisites for a course
- Create a queue to process courses
    - Start with zero dependency nodes
    - Look through neighbors and decrease respective dependency counts by 1 for wvery neighbor
    - Add nodes that no longer have any dependencies
    - If you clear all nodes after finishing the queue, then return True. Else return False

**Notes**
- A **direct graph** is 
- An **adjacency list** is a type of graph where the nodes are stored in a list and the values of each element are the neighbors of the given node.

---

### January 11, 2022

**Problem:** #56 Merge Intervals
**Category:** Intervals

**Solution**
- Have a variable that holds the current interval
- Sort the list of intervals by starting index
- Since they are sorted by starting index, we are assuming that the next interval will always have a start that is greater than or equal to the current index
- Traverse through the list of intervals with 2 possible outcomes
    1. first end < second end
    2. second start > first end
- Append last interval and return output list

**Notes**
- Recall how to use Python built-in sorted function

---

### January 12, 2022

**Problem:** #141 Detect a Cycle in a Linked-List
**Category:** Linked-List

**Solution**
- Use the Floyd's Cycle Detection Algorithm
- Condition for the while loop should be if fast and fast.next both do NOT equal None

**Notes**
- Floyd's Cycle Detection Algorithm has multiple uses
    - detects if a cycle exists in a linked-list
    - calculates the mid point of a linked-list
    -
- Details of the algorithm
    - slow pointer: Traverses through the linked list normally
    - fast-pointer: Traverses through the linked list twice as fast
    - Ex. slow = list.next, fast = list.next.next
    - Since the fast poitner is moving twice as quick it should either reach the end of the list, where the slow pointer indicates the middle of the list, OR the fast pointer will catch up to the slow pointer and detect that a cycle exists within the linked-list.

---

### January 13, 2022

**Problem:** #54 Spiral Matrix
**Category:** Matrices

**Solution**
- Use a two-pointer boundary for both directions of the matrix ( left, right & top, bottom)
- Have a while condition where left > right and bottom > top
- Loop through each direction printing each element and then shifting the boundary over once complete
    - Ex. After processing the first three elements in the first row, we want to shift the top boundary down because we have already processed those elements.

**Notes**
- Be careful of accessing certain elements, the ranges of the functions differ as you traverse through the loop of the matrix.

---

### January 14, 2022

**Problem:** #424 Longest Repeating String Replacement
**Category:** Strings

**Solution**
- Utilize a hashmap to store the counts of each letter and deduce the most repeating char
- Calculate the max possible size of the window by taking the length of the 

**Notes**
- 

---

### January 16, 2022

**Problem:** #100 Same Tree
**Category:** Tree

**Solution**
- Recursive solution
    - Base Case
        1. Check if both values are null
        2. Check if one value is null while the other is not
        3. Check if both values are not null, but not equal
    - Recursive Base
        - This is the case where both values are equal to the same value
        - Recursively check if the left subtree and the right subtree are the same of those nodes

- Iterative solution

**Notes**
- Tree problems mean you can solve them recursively or iteratively
- Reviewing structural differences of trees

---

### January 17, 2022

**Problem:** #217 Contains Duplicate
**Category:** Array

**Solution**
- Initialize a set for the elements as they are processed.
- If a number is encountered that is already in the set, then there are duplicates and the program should return True
- If the program is able to process all elements and exit the loop, return False

**Notes**
- A **set** is a special type of list that can only contain one of each element and is immutable

---

### January 18, 2022

**Problem:** #338 Counting Bits
**Category:** Binary / Dynamic Programming

**Solution**
- Initialize an array that starts at 0
- Loop from 0 to n
- Store the previous answers in the cache to reference later
- After finishing the algorithm, append the digit and restart
- Return the output array

**Notes**
- Recognize the pattern for dynamic programming
- Just because the problem doesn't implicitly say "DP" that you can't break it down into a DP problem

---

### January 19, 2022

**Problem:** #300 Longest Increasing Subsequence
**Category:** Dynamic Programming

**Solution**
- Attempted Solution: 
    - Store a current longest substring and a max list 
    - If a larger value than the value most recently added was encountered, add that value to the current list.
    - If a smaller or equal value was encounterded, check to see if the current list is longer than the max stored list. If current > max than update max.
    - Reset the current to be the most recent encounterd element

- Solution:
    - 

**Notes**
- 

---

### January 21, 2022

**Problem:** #417 Pacific Atlantic Water Flow
**Category:** Graph

**Solution**
- DFS Solution
    - Initialize two boolean matrices for each ocean that indicate if the ocean can be reached or not.
    - Start at each node and dfs its neighbor >= node
    - Go through all nodes again and see if you reach both oceans

**Notes**
- If you revisit all visited nodes again, you will run into the recursion limit.  Try not re-visiting nodes if you hit them already

---

### January 23, 2022

**Problem:** #21 Merge Two Sorted Lists
**Category:** Linked-List

**Solution**
- Initialize an output head node that will hold the final linked-list
- Use a while loop to continuously iterate through each linked list comparing the values.
    - if l1 > l2, add l1.val and update l1 to be l1.next
    - vice versa for l2 > l1
- After finishing the loop, one of the two linked-lists will still be None empty, so you a conditional to figure out which list it is and add that to the output list

**Notes**
- 

---

### January 31, 2022

**Problem:** Self-Descriptive Number
**Category:** Strings

**Solution**
- Store a dictionary that holds the count of each letter
- Recognize the pattern of which letters have special characters
0:z, 2:w, 4:u, 6:x, 7:s, 8:g
- Removw all of these letters of each number from the counts
- Recognize special characters from the remaining numbers
- Append as you find numbers
- Don''t forget to sort at the end

**Notes**
- 

---

### February 3, 2022

Reviewed Easy LeetCode Problems:
- Two Sum
- Palindrome Number
- Valid Parentheses
- Climb Stairs
- Same Tree

---

